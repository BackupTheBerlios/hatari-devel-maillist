<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [hatari-devel] Fire button freezes Hatari in the Downfall game
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/hatari-devel/2011q2/index.html" >
   <LINK REL="made" HREF="mailto:hatari-devel%40lists.berlios.de?Subject=Re%3A%20%5Bhatari-devel%5D%20Fire%20button%20freezes%20Hatari%20in%20the%20Downfall%20game&In-Reply-To=%3C4DF27BA0.1080603%40corp.free.fr%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003562.html">
   <LINK REL="Next"  HREF="003569.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[hatari-devel] Fire button freezes Hatari in the Downfall game</H1>
    <B>Nicolas Pomar&#232;de</B> 
    <A HREF="mailto:hatari-devel%40lists.berlios.de?Subject=Re%3A%20%5Bhatari-devel%5D%20Fire%20button%20freezes%20Hatari%20in%20the%20Downfall%20game&In-Reply-To=%3C4DF27BA0.1080603%40corp.free.fr%3E"
       TITLE="[hatari-devel] Fire button freezes Hatari in the Downfall game">npomarede at corp.free.fr
       </A><BR>
    <I>Fri Jun 10 22:16:32 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="003562.html">[hatari-devel] Fire button freezes Hatari in the Downfall game
</A></li>
        <LI>Next message: <A HREF="003569.html">[hatari-devel] Debugger usage examples?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3564">[ date ]</a>
              <a href="thread.html#3564">[ thread ]</a>
              <a href="subject.html#3564">[ subject ]</a>
              <a href="author.html#3564">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Le 10/06/2011 22:00, Eero Tamminen a &#233;crit :
&gt;<i> Hi,
</I>&gt;<i>
</I>&gt;<i> On tiistai 28 joulukuu 2010, Eero Tamminen wrote:
</I>&gt;&gt;<i> On perjantai 24 joulukuu 2010, Nicolas Pomar&#232;de wrote:
</I>&gt;&gt;&gt;&gt;<i> Ok, I've fixed it now: As expected, the problem was not due to the
</I>&gt;&gt;&gt;&gt;<i> delay value there, but something different:
</I>&gt;&gt;&gt;&gt;<i> Since it continually issued this command during the title screen,
</I>&gt;&gt;&gt;&gt;<i> Hatari continually tried to put three bytes into the internal keyboard
</I>&gt;&gt;&gt;&gt;<i> buffer. But the game did not consume the bytes as fast as issuing the
</I>&gt;&gt;&gt;&gt;<i> command,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Does that happen also in real ST?
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> so it finally flooded our Keyboard.Buffer ... in the end, we
</I>&gt;&gt;&gt;&gt;<i> could not put the whole packet into the buffer anymore, and the game
</I>&gt;&gt;&gt;&gt;<i> hang due to these incomplete answers.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Hatari Keyboard buffer size seems to be 1024 bytes (and input buffer size
</I>&gt;&gt;<i> 8 bytes).  What the real HW buffer sizes are?
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> To avoid this situation, I've put a check to only execute this command
</I>&gt;&gt;&gt;&gt;<i> if there is enough space left in our Keyboard.Buffer!
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Interesting, I wonder what a real ikbd does on an ST ?
</I>&gt;&gt;&gt;<i> Does the ikbd stop sending bytes because it detects the 68000 has not
</I>&gt;&gt;&gt;<i> read the already sent bytes, or does it continuously send the bytes too
</I>&gt;&gt;&gt;<i> and they overwrite the last byte sent previously ?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Or does it work like ring buffer so that newest packets overwrite oldest
</I>&gt;&gt;<i> ones?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> (if packets are of fixed size, I would assume this to be the case, but
</I>&gt;&gt;<i> with variable sized packets, it would need to keep track of of all of
</I>&gt;&gt;<i> them to avoid broken packages.)
</I>&gt;<i>
</I>&gt;<i> Did anybody every check these?
</I>&gt;<i>
</I>
At the hardware level (acia and ikbd), the ST has no such &quot;big&quot; buffer.

The acia will receive bytes from the ikbd and each each byte received 
from the ikbd will overwrite the current byte in the acia's RX buffer 
(which is just one byte). If this byte was not read by the 68000 before 
being overwritten, then a bit is set in the acia's status byte to 
indicate a byte was lost. So the buffer is in fact only 1 byte long 
(plus a shifting byte use to receive data on the serial line between 
ikbd and acia, but you can't acces this directly).

Now it is of course possible to code an interrupt handler to immediatly 
read any newly received byte in the acia and store it in a larger ring 
buffer so that the main program can handle it later. This way you won't 
lost bytes sent by the ikbd.

So, a ring buffer will be handled at software level, not built in the 
hardware (but due to an incomplete acia/ikbd implementation in Hatari, 
it's possible that some bytes are still lost in some case and that some 
demos/games don't behave as expected)

Nicolas


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003562.html">[hatari-devel] Fire button freezes Hatari in the Downfall game
</A></li>
	<LI>Next message: <A HREF="003569.html">[hatari-devel] Debugger usage examples?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3564">[ date ]</a>
              <a href="thread.html#3564">[ thread ]</a>
              <a href="subject.html#3564">[ subject ]</a>
              <a href="author.html#3564">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/hatari-devel">More information about the hatari-devel
mailing list</a><br>
</body></html>
